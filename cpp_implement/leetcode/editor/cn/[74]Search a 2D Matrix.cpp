// You are given an m x n integer matrix matrix with the following two// properties://////  Each row is sorted in non-decreasing order.//  The first integer of each row is greater than the last integer of the// previous row.//////  Given an integer target, return true if target is in matrix or false// otherwise.////  You must write a solution in O(log(m * n)) time complexity.//////  Example 1:////// Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3// Output: true//////  Example 2:////// Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13// Output: false////////  Constraints://////  m == matrix.length//  n == matrix[i].length//  1 <= m, n <= 100//  -10⁴ <= matrix[i][j], target <= 10⁴//////  Related Topics 数组 二分查找 矩阵 👍 1046 👎 0#include <vector>// leetcode submit region begin(Prohibit modification and deletion)class Solution {   public:    bool searchMatrix(std::vector<std::vector<int>>& matrix, int target) {        int m = matrix.size(), n = matrix[0].size();        if (m == 1 && n == 1) {            return matrix[0][0] == target;        }        return BinarySearch(matrix, target, 0, m * n - 1);    }   private:    bool BinarySearch(std::vector<std::vector<int>>& matrix, int target,                      int left, int right) {        // 递归调用的退出条件,千万不要忘记了.        if (left > right) {            return false;        }        int mid   = left + (right - left) / 2;        int n     = matrix[0].size();        int i     = mid / n;        int j     = mid % n;        int value = matrix[i][j];        if (value == target) {            return true;        } else if (value < target) {            return BinarySearch(matrix, target, mid + 1, right);        } else {            return BinarySearch(matrix, target, left, mid - 1);        }    }};// leetcode submit region end(Prohibit modification and deletion)